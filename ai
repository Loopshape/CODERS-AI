#!/usr/bin/env bash
# Author: Aris Arjuna Noorsanto <exe.opcode@gmail.com>
# Singlefile Shell-Automation für Unix (Debian / Termux proot-distro non-root)
# Zweck: Wrapper um `ollama run gemma3:1b` mit eingebetteten Scriptrules (DE),
#        modularen Routinen, rekursiver Ausführungslogik, Fold/Unfold und Caching
#
# Hinweis: Dieses Skript ist portabel, nicht-root-freundlich und bleibt komplett
#         in einer einzigen Datei. Anpassungen an die konkrete ollama-CLI-Version
#         können erforderlich sein (siehe Funktion `ollama_exec`).
#
# Usage:
#   chmod +x ~/bin/ai_automation.sh
#   ./ai_automation.sh help
#
# Designprinzipien (Kurz):
# - alles modular als Routinen (indexed)
# - rekursives Ausführen mit Deduplizierung (kein Doppel-Work)
# - Prompt-Wrapper sendet die deutschen Scriptrules + Kontext an gemma3:1b
# - Ergebnisse werden gecached, Logs werden geschrieben
# - Für Termux/proot: läuft ohne root, prüft verfügbare Binaries

set -euo pipefail
IFS=$'\n\t'

# ---------------------------
# Konfiguration & Pfade
# ---------------------------
BASE_DIR="${HOME}/.ai_automation"
CACHE_DIR="$BASE_DIR/cache"
LOG_DIR="$BASE_DIR/logs"
TMP_DIR="$BASE_DIR/tmp"
mkdir -p "$CACHE_DIR" "$LOG_DIR" "$TMP_DIR"

LOG_FILE="$LOG_DIR/ai_automation.log"
DATE_STAMP() { date -u +"%Y-%m-%dT%H:%M:%SZ"; }

# ---------------------------
# Logging Helpers
# ---------------------------
log()    { printf '%s %s\n' "$(DATE_STAMP)" "$*" | tee -a "$LOG_FILE"; }
info()   { log "[INFO] $*"; }
warn()   { log "[WARN] $*"; }
error()  { log "[ERROR] $*"; }
success(){ log "[OK] $*"; }

# ---------------------------
# Environment Detection
# ---------------------------
detect_env() {
    info "Ermittle Umgebung..."
    # detect termux/proot vs Debian
    if grep -q -i termux /proc/version 2>/dev/null || [[ -n "${PREFIX:-}" && "$PREFIX" == "/data/data/com.termux/files/usr" ]]; then
        ENV="termux"
    elif command -v apt-get &>/dev/null; then
        ENV="debian"
    else
        ENV="generic"
    fi
    info "Gefundene Umgebung: $ENV"
}

# ---------------------------
# Ollama CLI Helpers (flexible)
# ---------------------------
ollama_available() {
    if command -v ollama &>/dev/null; then
        return 0
    fi
    return 1
}

# Versucht verschiedene Aufrufweisen — passe an deine ollama-CLI an falls nötig.
ollama_exec() {
    local prompt_file="$1"
    # prefer piping to stdin; fallback to argument
    if ollama_available; then
        # Try streaming-less run; many ollama versions accept stdin
        if response=$(cat "$prompt_file" | ollama run gemma3:1b --no-stream 2>/dev/null); then
            printf '%s' "$response"
            return 0
        fi
        # fallback: entire prompt as single argument (might fail on very long prompts)
        if response=$(ollama run gemma3:1b "$(cat "$prompt_file")" 2>/dev/null); then
            printf '%s' "$response"
            return 0
        fi
        # last resort: simple run and hope for the best
        if response=$(ollama run gemma3:1b 2>/dev/null <<<"$(cat "$prompt_file")"); then
            printf '%s' "$response"
            return 0
        fi
        # nothing worked
        return 1
    else
        return 2
    fi
}

# Startet ollama server falls nicht laufend (versucht, permissiv)
ensure_ollama_server() {
    if ! ollama_available; then
        warn "ollama nicht im PATH gefunden. Bitte installiere ollama oder setze PATH entsprechend."
        return 1
    fi
    # kill alte Instanzen, starte neu (non-root safe: versucht, falls möglich)
    info "Stoppe vorhandene ollama Prozesse (wenn vorhanden)..."
    pkill ollama &>/dev/null || true
    info "Starte ollama serve im Hintergrund..."
    # & disown so that prozess weiterläuft
    ollama serve &>/dev/null &
    sleep 1
    # prüfe ob server erreichbar (best effort)
    if ! curl --silent --max-time 2 http://localhost:11434/ >/dev/null 2>&1; then
        warn "Ollama-Server ist nicht erreichbar auf http://localhost:11434 - prüfe ollama serve logs."
    else
        success "Ollama Server läuft."
    fi
    return 0
}

# ---------------------------
# Embedded Deutsche Scriptrules (UNIVERSAL LAW)
# ---------------------------
read -r -d '' SCRIPTRULES_DE <<'EOF' || true
:BOF:
(1) Singlefile-Prinzip: Alle Logiken bleiben in einer Datei (kein Split).
(2) Modulare Routinen: Jede Aufgabe ist eine benannte Routine, indexiert und wiederverwendbar.
(3) Rekursive Ausführung: Routinen können andere Routinen aufrufen; Doppelarbeit wird verhindert.
(4) Fold/Unfold: Routinen sind "faltbar" — Übersicht behalten durch Auflistung + Anzeige.
(5) Caching: Ergebnisse von Routinen werden persistiert, um Wiederholung zu sparen.
(6) Prompt-Wrapper: Alle an 'gemma3:1b' gesendeten Prompts enthalten die Scriptrules in Deutsch.
(7) Sicherheitsregeln: Robots.txt beachten beim Webscraping; kein Root benötigt.
(8) Progression: Antworten sind in logischer Reihenfolge auszugeben; Fortschritt wird protokolliert.
(9) Erweiterbarkeit: Neue Usecases als Routinen hinzufügen, mit Metadaten dokumentiert.
(10) Wiederverwendung: Routinen sollten idempotent sein oder durch Cache/Hash gesteuert werden.
:EOF:
EOF

# ---------------------------
# Routine-Registry (in-memory) + Persistent Cache
# ---------------------------
declare -A ROUTINE_BODY    # mapping: name -> code snippet (string)
declare -A ROUTINE_DOCS    # mapping: name -> docstring
declare -A ROUTINE_INDEX   # mapping: index -> name
declare -A EXECUTED_SET    # mapping: name:hash -> 1 (prevent duplicates)

ROUTINE_COUNTER=0

register_routine() {
    local name="$1"; shift
    local doc="$1"; shift
    local body="$1"
    ROUTINE_BODY["$name"]="$body"
    ROUTINE_DOCS["$name"]="$doc"
    ROUTINE_INDEX["$ROUTINE_COUNTER"]="$name"
    ROUTINE_COUNTER=$((ROUTINE_COUNTER+1))
    info "Routine registriert: $name"
}

list_routines() {
    printf '%s\n' "== Registrierte Routinen =="
    for i in "${!ROUTINE_INDEX[@]}"; do
        local n="${ROUTINE_INDEX[$i]}"
        printf '%3d) %-20s - %s\n' "$i" "$n" "${ROUTINE_DOCS[$n]}"
    done
}

show_routine() {
    local name="$1"
    printf '%s\n' "== Routine: $name =="
    printf '%s\n\n' "${ROUTINE_DOCS[$name]}"
    printf '%s\n' "${ROUTINE_BODY[$name]}"
}

# ---------------------------
# Routine Execution Engine (rekursiv, deduplizierend)
# ---------------------------
# execute_routine <name> <arg-json> <depth>
# arg-json is optional JSON-like string (simple key=value pairs separated by ;)
execute_routine() {
    local name="$1"
    local args="$2"
    local depth="${3:-0}"
    local indent="$(printf '%*s' $((depth*2)) '')"

    if [[ -z "${ROUTINE_BODY[$name]:-}" ]]; then
        error "${indent}Routine nicht gefunden: $name"
        return 1
    fi

    # Compute a simple cache key based on name+args
    local key
    key="$(printf '%s|%s' "$name" "$args" | sha1sum | awk '{print $1}')"
    if [[ -n "${EXECUTED_SET[$key]:-}" ]]; then
        info "${indent}Bereits ausgeführt (Cache): $name"
        return 0
    fi

    info "${indent}Starte Routine: $name (depth=${depth})"
    # Write routine to tmp file and execute in a subshell to keep isolation
    local tmp="$TMP_DIR/rt_${name}_${key}.sh"
    cat > "$tmp" <<'SCRIPT'
#!/usr/bin/env bash
set -euo pipefail
# Routine Runner
SOURCE_ARGS="$@"
# Routine body begins
__BODY__
# Routine body ends
SCRIPT
    # insert body
    local body="${ROUTINE_BODY[$name]}"
    # replace placeholder
    sed -i "s|__BODY__|$body|g" "$tmp"
    chmod +x "$tmp"

    # Execute (pass args)
    "$tmp" "$args"
    local rc=$?
    if [[ $rc -eq 0 ]]; then
        EXECUTED_SET[$key]=1
        info "${indent}Routine abgeschlossen: $name"
    else
        error "${indent}Routine fehlgeschlagen: $name"
    fi
    rm -f "$tmp"
    return $rc
}

# ---------------------------
# Caching Helpers
# ---------------------------
cache_put() {
    local key="$1"; local data="$2"
    printf '%s' "$data" > "$CACHE_DIR/$key"
}
cache_get() {
    local key="$1"
    if [[ -f "$CACHE_DIR/$key" ]]; then
        cat "$CACHE_DIR/$key"
        return 0
    fi
    return 1
}

# ---------------------------
# Utility: create prompt for Ollama (DE) incorporating rules + context
# ---------------------------
build_ollama_prompt() {
    local context="$1"
    local role="${2:-System}"
    local prompt_file="$TMP_DIR/prompt_$(date +%s%N).txt"
    {
        printf '%%s\n' "Du bist ein erfahrener Entwickler und Assistenzsystem."
        printf '\n'
        printf '%s\n' "Eingebettete Scriptrules (Deutsch):"
        printf '%s\n\n' "$SCRIPTRULES_DE"
        printf '%s\n' "Kontext / Inhalt:"
        printf '%s\n' "----- BEGIN CONTEXT -----"
        printf '%s\n' "$context"
        printf '%s\n' "----- END CONTEXT -----"
        printf '\n'
        printf '%s\n' "Anweisung an das Modell:"
        printf '%s\n' "- Antworte in Deutsch."
        printf '%s\n' "- Gib strukturierte, wiederverwendbare Routinen aus (falls Code: in eindeutigen Codeblöcken)."
        printf '%s\n' "- Wenn ein Artefakt geliefert werden soll: liefere es als base64-tar.gz oder als JSON mapping pfad->inhalt."
        printf '%s\n' "- Keine frei-form Kommentare außerhalb der spezifizierten Ausgabeformate."
        printf '\n'
        printf '%s\n' "Beginne jetzt mit der geforderten Arbeit."
    } > "$prompt_file"
    printf '%s' "$prompt_file"
}

# ---------------------------
# High-level: Feed Blog & Ask gemma3:1b for Project (DE)
# ---------------------------
# feed_blog_and_request_project <source> <outdir>
feed_blog_and_request_project() {
    local source="$1"
    local outdir="${2:-./ai_out}"
    mkdir -p "$outdir"
    local blog
    if [[ "$source" =~ ^https?:// ]]; then
        if ! command -v curl &>/dev/null; then
            error "curl fehlt; benötigtes Werkzeug für URL-Download."
            return 1
        fi
        info "Lade URL: $source"
        blog="$(curl -sL "$source")"
    else
        if [[ ! -f "$source" ]]; then
            error "Datei nicht gefunden: $source"
            return 1
        fi
        blog="$(cat "$source")"
    fi

    # build prompt
    local pf
    pf="$(build_ollama_prompt "$blog")"
    info "Prompt gebaut: $pf"

    # ensure ollama server is running
    ensure_ollama_server || warn "Ollama Server: Start nicht erfolgreich, fahre dennoch fort."

    # call ollama
    info "Sende Prompt an gemma3:1b..."
    if ! ollama_exec "$pf" > "$TMP_DIR/model_response.txt"; then
        error "Fehler beim Aufruf von ollama. Prüfe Installation und Server."
        return 1
    fi
    info "Antwort gespeichert: $TMP_DIR/model_response.txt"

    # Save a copy to outdir for inspection
    cp "$TMP_DIR/model_response.txt" "$outdir/model_response.txt"

    # Try to detect base64 payload (best-effort)
    local b64file="$outdir/project.b64"
    grep -v '^\s*```' "$TMP_DIR/model_response.txt" > "$b64file" || true

    # attempt decode
    if base64 -d "$b64file" > "$outdir/project.tgz" 2>/dev/null; then
        info "Base64 erfolgreich dekodiert -> Entpacke..."
        mkdir -p "$outdir/project"
        tar -xzf "$outdir/project.tgz" -C "$outdir/project"
        success "Projekt extrahiert nach: $outdir/project"
    else
        warn "Konnte Base64 nicht dekodieren. Model-Antwort prüfen: $outdir/model_response.txt"
    fi
}

# ---------------------------
# Beispiel-Routinen registrieren (Beispiel: html-enhancement, web-scrape)
# ---------------------------
register_defaults() {
    register_routine "html_enhance" "Enhance HTML: inject theme, ARIA, annotate JS funcs" $'#!/usr/bin/env bash\nset -euo pipefail\nfile="$1"\nif [[ -z "$file" || ! -f "$file" ]]; then echo "file missing"; exit 1; fi\nsed -i.bak -E \\\\ \\\'s|<head>|<head><style>:root{--main-bg:#8B0000;--main-fg:#fff;}}</style>|\\\' \"$file\"\n# note: simplified body\nexit 0'
    register_routine "web_scrape" "Lade URL herunter, respektiere robots.txt und speichere snapshot" $'#!/usr/bin/env bash\nset -euo pipefail\nurl=\"$1\"\ndomain=$(echo \"$url\" | awk -F/ \'{print $3}\')\nmkdir -p \"$BASE_DIR/snapshots\"\nif command -v curl &>/dev/null; then curl -sL \"$url\" -o \"$BASE_DIR/snapshots/${domain}.html\"; fi\nexit 0'
}

# ---------------------------
# CLI: Helfer / Hilfetext
# ---------------------------
usage() {
    cat <<EOF
AI Automation - Singlefile Shell-Automation (DE)

Usage:
  $0 help                       - Diese Hilfe
  $0 env                        - Umgebungserkennung
  $0 list                       - Auflistung registrierter Routinen
  $0 show <routine>             - Zeige Routine-Quelltext
  $0 run <routine> [argstr]     - Führe registrierte Routine aus (argstr optional)
  $0 feed <blog> [outdir]       - Blog (Datei/URL) einspeisen und Projekt anfordern
  $0 init_ollama                - Ollama Server starten (pkill+serve)
  $0 register_defaults          - Registriere Beispielroutinen
  $0 help                       - Dieser Text

Beispiel:
  $0 init_ollama
  $0 register_defaults
  $0 list
  $0 run html_enhance ./index.html

EOF
}

# ---------------------------
# Boot / CLI Router
# ---------------------------
detect_env
register_defaults

case "${1:-help}" in
    help) usage ;;
    env) info "ENV: $ENV";;
    init_ollama) ensure_ollama_server ;;
    list) list_routines ;;
    show) show_routine "${2:-}" ;;
    run) if [[ -z "${2:-}" ]]; then error "Kein Routinenname"; usage; else execute_routine_name="$2"; execute_args="${3:-}"; execute_routine "$execute_routine_name" "$execute_args" 0; fi ;;
    feed) feed_blog_and_request_project "${2:-}" "${3:-./ai_generated}" ;;
    register_defaults) register_defaults; info "Defaults registriert." ;;
    *) usage ;;
esac

exit 0