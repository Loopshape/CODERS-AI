<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>NEXUS Cluster Visualizer</title>
<style>
  body { margin:0; overflow:hidden; background:#0b0f1a; color:#ddd; font-family:monospace; }
  #overlay { position:absolute; left:10px; top:10px; z-index:10; background:rgba(0,0,0,0.4); padding:8px; border-radius:6px;}
  #log { max-height:220px; overflow:auto; width:360px; font-size:12px; }
  #prompt-container {
    position: absolute;
    bottom: 20px;
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center; /* Align items vertically in the center */
    gap: 10px; /* Space between input and button */
    z-index: 10;
  }
  #prompt-input {
    width: 60%;
    max-width: 700px;
    padding: 15px 20px;
    border-radius: 25px;
    border: 1px solid #555;
    background-color: #222;
    color: #ddd;
    font-size: 16px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    outline: none;
    resize: vertical;
    min-height: 50px;
  }
  #prompt-input:focus {
    border-color: #888;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
  }
  #send-prompt-button {
    background-color: #4CAF50; /* Green */
    color: white;
    padding: 15px 20px;
    border: none;
    border-radius: 25px;
    cursor: pointer;
    font-size: 16px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    transition: background-color 0.3s ease;
    height: 50px; /* Match min-height of textarea */
  }
  #send-prompt-button:hover {
    background-color: #45a049;
  }
  .log-entry-agent-pulse {
    font-weight: bold;
    color: #ffcc00; /* A color to indicate activity */
    transition: color 0.5s ease-out;
  }
</style>
</head>
<body>
<div id="overlay">
  <div><b>NEXUS â€” Live Agents</b></div>
  <div id="log"></div>
</div>
<div id="prompt-container">
  <textarea id="prompt-input" placeholder="Enter your prompt here..."></textarea>
  <button id="send-prompt-button">Send</button>
</div>
<div id="agent-detail-card" style="
  position: absolute;
  background: rgba(0, 0, 0, 0.8);
  border: 1px solid #00ffff;
  border-radius: 8px;
  padding: 15px;
  color: #fff;
  font-family: monospace;
  font-size: 14px;
  z-index: 100;
  display: none; /* Hidden by default */
  pointer-events: none; /* Allows clicks to pass through when hidden */
  min-width: 200px;
  max-width: 300px;
  box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
">
  <h3>Agent: <span id="card-agent-name"></span></h3>
  <p>Status: <span id="card-agent-status"></span></p>
  <p>Last Activity: <span id="card-agent-last-activity"></span></p>
  <p>Tokens Used: <span id="card-agent-tokens-used"></span></p>
</div>

<pre id="final-code-display" style="
  position: absolute;
  bottom: 80px; /* Adjust based on prompt-container height */
  left: 50%;
  transform: translateX(-50%);
  width: 90%;
  max-width: 800px;
  max-height: 400px;
  overflow: auto;
  background: rgba(0, 0, 0, 0.7);
  border: 1px solid #00ffcc;
  border-radius: 8px;
  padding: 15px;
  color: #00ffcc;
  font-family: 'Fira Code', 'Cascadia Code', monospace;
  font-size: 14px;
  z-index: 9;
  display: none; /* Hidden by default */
  white-space: pre-wrap;
  word-break: break-all;
  box-shadow: 0 0 20px rgba(0, 255, 204, 0.3);
"></pre>

<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>
const AGENTS = ["cube","core","loop","wave","line","coin","code","work"];
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);
camera.position.z = 6;

// Particle System properties
const PARTICLE_COUNT_PER_AGENT = 50;
const PARTICLE_SIZE = 0.05;
const PARTICLE_SPEED = 0.01;
const PARTICLE_LIFETIME = 50; // frames
const BURST_PARTICLE_COUNT = 10; // Number of particles to burst on message
const TOKEN_POOL_PARTICLE_COUNT = 100; // Number of particles for the token pool
const ENTROPY_FACTOR = 0.0005; // Controls the randomness/chaos of particle movement

// Create a particle texture (white circle)
const particleCanvas = document.createElement('canvas');
particleCanvas.width = 64;
particleCanvas.height = 64;
const pctx = particleCanvas.getContext('2d');
pctx.beginPath();
pctx.arc(32, 32, 30, 0, Math.PI * 2, false);
pctx.fillStyle = 'rgba(255, 255, 255, 1)';
pctx.fill();
const particleTexture = new THREE.CanvasTexture(particleCanvas);

const nodes = {};
const agentMeshes = []; // Array to store agent meshes for raycasting
const group = new THREE.Group();
scene.add(group);

// Central Token Pool
const tokenPoolGeometry = new THREE.SphereGeometry(0.7, 32, 32);
const tokenPoolMaterial = new THREE.MeshStandardMaterial({ color: 0x0077ff, emissive: 0x0033aa, emissiveIntensity: 0.7 });
const tokenPool = new THREE.Mesh(tokenPoolGeometry, tokenPoolMaterial);
scene.add(tokenPool);

// Particle system for Token Pool
const tpParticlesGeometry = new THREE.BufferGeometry();
const tpParticlePositions = new Float32Array(TOKEN_POOL_PARTICLE_COUNT * 3);
const tpParticleVelocities = new Float32Array(TOKEN_POOL_PARTICLE_COUNT * 3);
const tpParticleStartTimes = new Float32Array(TOKEN_POOL_PARTICLE_COUNT);

for (let p = 0; p < TOKEN_POOL_PARTICLE_COUNT; p++) {
  // Initial position around the token pool
  tpParticlePositions[p * 3 + 0] = (Math.random() - 0.5) * tokenPoolGeometry.parameters.radius * 2;
  tpParticlePositions[p * 3 + 1] = (Math.random() - 0.5) * tokenPoolGeometry.parameters.radius * 2;
  tpParticlePositions[p * 3 + 2] = (Math.random() - 0.5) * tokenPoolGeometry.parameters.radius * 2;

  tpParticleVelocities[p * 3 + 0] = 0; // Initially stationary
  tpParticleVelocities[p * 3 + 1] = 0;
  tpParticleVelocities[p * 3 + 2] = 0;
  
  tpParticleStartTimes[p] = -1; // -1 indicates inactive
}

tpParticlesGeometry.setAttribute('position', new THREE.BufferAttribute(tpParticlePositions, 3));
tpParticlesGeometry.setAttribute('startTime', new THREE.BufferAttribute(tpParticleStartTimes, 1));

const tpParticlesMaterial = new THREE.PointsMaterial({
  size: PARTICLE_SIZE * 1.5, // Slightly larger particles for token pool
  map: particleTexture,
  blending: THREE.AdditiveBlending,
  depthWrite: false,
  transparent: true,
  vertexColors: false,
  color: 0x00ffff, // Cyan color for token pool particles
});

const tokenPoolParticles = new THREE.Points(tpParticlesGeometry, tpParticlesMaterial);
scene.add(tokenPoolParticles);

// create nodes in a circle
const R = 3.0;
AGENTS.forEach((a,i)=>{
  const angle = (i/AGENTS.length) * Math.PI * 2;
  const x = Math.cos(angle)*R, y = Math.sin(angle)*R;
  const geom = new THREE.SphereGeometry(0.35, 24, 16);
  const mat = new THREE.MeshStandardMaterial({color:0x334455});
  const mesh = new THREE.Mesh(geom, mat);
  mesh.name = a; // Give the mesh a name to identify it later
  mesh.position.set(x,y,0);
  group.add(mesh);
  agentMeshes.push(mesh); // Add mesh to the array for raycasting
  // label via sprite
  const canvas = document.createElement('canvas'); canvas.width=256; canvas.height=64;
  const ctx = canvas.getContext('2d'); ctx.fillStyle='white'; ctx.font='28px monospace'; ctx.fillText(a,10,40);
  const tex = new THREE.CanvasTexture(canvas);
  const sp = new THREE.Sprite(new THREE.SpriteMaterial({map:tex}));
  sp.scale.set(1.5,0.4,1); sp.position.set(x, y-0.6, 0);
  group.add(sp);

  // Activity level via sprite
  const levelCanvas = document.createElement('canvas'); levelCanvas.width=256; levelCanvas.height=64;
  const levelCtx = levelCanvas.getContext('2d'); levelCtx.fillStyle='white'; levelCtx.font='20px monospace'; levelCtx.fillText('Level: 0',10,40);
  const levelTex = new THREE.CanvasTexture(levelCanvas);
  const levelSp = new THREE.Sprite(new THREE.SpriteMaterial({map:levelTex}));
  levelSp.scale.set(1.5,0.4,1); levelSp.position.set(x, y-1.0, 0); // Position below agent label
  group.add(levelSp);

  // Connection line to token pool
  const points = [];
  points.push(mesh.position);
  points.push(tokenPool.position);
  const geometry = new THREE.BufferGeometry().setFromPoints(points);
  const material = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3 });
  const line = new THREE.Line(geometry, material);
  group.add(line);
  
  // Particle system for agent
  const particlesGeometry = new THREE.BufferGeometry();
  const particlePositions = new Float32Array(PARTICLE_COUNT_PER_AGENT * 3);
  const particleVelocities = new Float32Array(PARTICLE_COUNT_PER_AGENT * 3);
  const particleStartTimes = new Float32Array(PARTICLE_COUNT_PER_AGENT);

  for (let p = 0; p < PARTICLE_COUNT_PER_AGENT; p++) {
    // Initial position slightly offset from agent
    particlePositions[p * 3 + 0] = x + (Math.random() - 0.5) * 0.1;
    particlePositions[p * 3 + 1] = y + (Math.random() - 0.5) * 0.1;
    particlePositions[p * 3 + 2] = (Math.random() - 0.5) * 0.1;

    // Initial velocity outwards
    particleVelocities[p * 3 + 0] = (Math.random() - 0.5) * PARTICLE_SPEED;
    particleVelocities[p * 3 + 1] = (Math.random() - 0.5) * PARTICLE_SPEED;
    particleVelocities[p * 3 + 2] = (Math.random() - 0.5) * PARTICLE_SPEED;
    
    particleStartTimes[p] = -1; // -1 indicates inactive
  }

  particlesGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
  particlesGeometry.setAttribute('startTime', new THREE.BufferAttribute(particleStartTimes, 1)); // Custom attribute

  const particlesMaterial = new THREE.PointsMaterial({
    size: PARTICLE_SIZE,
    map: particleTexture,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    transparent: true,
    vertexColors: false, // Will use material color
  });
  particlesMaterial.color.setHSL(Math.random(), 1.0, 0.5); // Random color for each agent's particles

  const particles = new THREE.Points(particlesGeometry, particlesMaterial);
  group.add(particles);
  
  nodes[a] = {
    mesh, tex, last:Date.now(), line, levelTex, levelSp,
    status: 'Idle',
    tokensUsed: 0,
    lastActivity: new Date().toLocaleTimeString(),
    particles, particlePositions, particleVelocities, particleStartTimes, particlesGeometry,
  };
});

// light
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(5,5,5); scene.add(light);
const ambient = new THREE.AmbientLight(0x404040); scene.add(ambient);

function animate(){
  requestAnimationFrame(animate);
  group.rotation.z += 0.002;
  // fade nodes back to base color
      const now = Date.now();
      for(const a in nodes){
        const n = nodes[a];
        const age = (now - n.last)/1000;
        const t = Math.max(0, Math.min(1, 1 - age/3)); // More intense and faster fade
        const base = new THREE.Color(0x334455);
        const hot = new THREE.Color(0xff9933);
        n.mesh.material.color.lerpColors(base, hot, t);
    // Fade connection lines
    if (n.line) {
      const lineAge = (now - n.last) / 1000;
      const lineT = Math.max(0, Math.min(1, 1 - lineAge / 2)); // Fade out faster
      n.line.material.opacity = 0.3 + 0.7 * lineT; // Fade from 1.0 to 0.3
      n.line.material.color.lerpColors(new THREE.Color(0x00ffff), new THREE.Color(0xff00ff), lineT); // Fade from hot color to base
    }

    // Update activity level
    const activityLevel = Math.max(0, Math.round(10 - age)); // Map age to 0-10, 0s -> 10, 10s+ -> 0
    const levelCtx = n.levelTex.image.getContext('2d');
    levelCtx.clearRect(0,0,256,64);
    levelCtx.fillStyle='white'; levelCtx.font='20px monospace';
    levelCtx.fillText(`Level: ${activityLevel}`, 8, 34);
    n.levelTex.needsUpdate = true;

    // Update agent particles
    const particlePositions = n.particlesGeometry.attributes.position.array;
    const particleStartTimes = n.particlesGeometry.attributes.startTime.array;
    const particleVelocities = n.particleVelocities; // Access from stored velocities

    for (let p = 0; p < PARTICLE_COUNT_PER_AGENT; p++) {
      const startTime = particleStartTimes[p];

      if (startTime < 0) continue; // Inactive particle

      const elapsed = (now - startTime) / 1000; // in seconds

      if (elapsed > PARTICLE_LIFETIME / 60) { // particle lifetime in seconds
        particleStartTimes[p] = -1; // Mark as inactive
        continue;
      }

      // Add random perturbation to velocity (entropy simulation)
      particleVelocities[p * 3 + 0] += (Math.random() - 0.5) * ENTROPY_FACTOR;
      particleVelocities[p * 3 + 1] += (Math.random() - 0.5) * ENTROPY_FACTOR;
      particleVelocities[p * 3 + 2] += (Math.random() - 0.5) * ENTROPY_FACTOR;

      // Update position
      particlePositions[p * 3 + 0] += particleVelocities[p * 3 + 0];
      particlePositions[p * 3 + 1] += particleVelocities[p * 3 + 1];
      particlePositions[p * 3 + 2] += particleVelocities[p * 3 + 2];

      // Fade out
      n.particles.material.opacity = 1 - (elapsed / (PARTICLE_LIFETIME / 60));
    }
    n.particlesGeometry.attributes.position.needsUpdate = true;
    n.particlesGeometry.attributes.startTime.needsUpdate = true;
  }

      // Fade token pool emissive intensity
      if (tokenPool.lastTokenReceived) {
        const poolAge = (now - tokenPool.lastTokenReceived) / 1000;
        const poolT = Math.max(0, Math.min(1, 1 - poolAge / 1.5)); // Fade out faster
        tokenPool.material.emissiveIntensity = 0.7 + 0.8 * poolT; // Fade from 1.5 to 0.7 (base)
      }
  
      // Update token pool particles
      const tpParticlePositions = tpParticlesGeometry.attributes.position.array;
      const tpParticleStartTimes = tpParticlesGeometry.attributes.startTime.array;
  
      for (let p = 0; p < TOKEN_POOL_PARTICLE_COUNT; p++) {
        const startTime = tpParticleStartTimes[p];
  
        if (startTime < 0) continue; // Inactive particle
  
        const elapsed = (now - startTime) / 1000; // in seconds
  
        if (elapsed > PARTICLE_LIFETIME / 60 * 2) { // Token pool particles live longer
          tpParticleStartTimes[p] = -1; // Mark as inactive
          continue;
        }

        // Add random perturbation to velocity (entropy simulation)
        tpParticleVelocities[p * 3 + 0] += (Math.random() - 0.5) * ENTROPY_FACTOR;
        tpParticleVelocities[p * 3 + 1] += (Math.random() - 0.5) * ENTROPY_FACTOR;
        tpParticleVelocities[p * 3 + 2] += (Math.random() - 0.5) * ENTROPY_FACTOR;
  
        // Update position
        tpParticlePositions[p * 3 + 0] += tpParticleVelocities[p * 3 + 0];
        tpParticlePositions[p * 3 + 1] += tpParticleVelocities[p * 3 + 1];
        tpParticlePositions[p * 3 + 2] += tpParticleVelocities[p * 3 + 2];
  
        // Fade out
        tokenPoolParticles.material.opacity = 1 - (elapsed / (PARTICLE_LIFETIME / 60 * 2));
      }
      tpParticlesGeometry.attributes.position.needsUpdate = true;
      tpParticlesGeometry.attributes.startTime.needsUpdate = true;
    }
    renderer.render(scene, camera);}
animate();

// Raycasting for agent clicks
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

function onMouseDown(event) {
  // Calculate mouse position in normalized device coordinates (-1 to +1)
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);

  // Check for intersections
  const intersects = raycaster.intersectObjects(agentMeshes);

  if (intersects.length > 0) {
    const clickedMesh = intersects[0].object;
    console.log('Clicked agent:', clickedMesh.name);
    // Show agent detail card
    showAgentDetailCard(clickedMesh.name, event.clientX, event.clientY);
  } else {
    hideAgentDetailCard();
  }
}

window.addEventListener('mousedown', onMouseDown, false);

// Agent Detail Card elements
const agentDetailCard = document.getElementById('agent-detail-card');
const cardAgentName = document.getElementById('card-agent-name');
const cardAgentStatus = document.getElementById('card-agent-status');
const cardAgentLastActivity = document.getElementById('card-agent-last-activity');
const cardAgentTokensUsed = document.getElementById('card-agent-tokens-used');

function showAgentDetailCard(agentName, mouseX, mouseY) {
  const agentData = nodes[agentName];
  if (!agentData) return;

  cardAgentName.textContent = agentName;
  cardAgentStatus.textContent = agentData.status;
  cardAgentLastActivity.textContent = agentData.lastActivity;
  cardAgentTokensUsed.textContent = agentData.tokensUsed;

  // Position the card
  agentDetailCard.style.left = `${mouseX + 15}px`; // Offset to the right of mouse
  agentDetailCard.style.top = `${mouseY + 15}px`;  // Offset below mouse
  agentDetailCard.style.display = 'block';
  agentDetailCard.style.pointerEvents = 'auto'; // Enable interaction with the card
}

function hideAgentDetailCard() {
  agentDetailCard.style.display = 'none';
  agentDetailCard.style.pointerEvents = 'none'; // Disable interaction when hidden
}

// Helper function to create log entries with styling
function createLogEntry(source, text, type) {
  const p = document.createElement('div');
  const sourceSpan = document.createElement('span');
  sourceSpan.textContent = `[${source}]`;
  sourceSpan.classList.add('log-entry-source');
  
  const messageSpan = document.createElement('span');
  messageSpan.textContent = ' ' + text;

  p.appendChild(sourceSpan);
  p.appendChild(messageSpan);

  if (type === 'error') {
    p.style.color = '#ff6666'; // Red for errors
  } else if (type === 'success') {
    p.style.color = '#66ff66'; // Green for success
  } else if (type === 'info') {
    p.style.color = '#66ccff'; // Blue for info
  } else if (type === 'ollama-stream') {
    // Maybe a distinct color for streamed Ollama output
    p.style.color = '#ccff66';
  }
  return p;
}


// Prompt input and send functionality
const promptInput = document.getElementById('prompt-input');
const sendPromptButton = document.getElementById('send-prompt-button');

sendPromptButton.addEventListener('click', sendPrompt);
promptInput.addEventListener('keydown', (event) => {
  if (event.key === 'Enter' && !event.shiftKey) {
    event.preventDefault(); // Prevent new line in textarea
    sendPrompt();
  }
});

async function sendPrompt() {
  const prompt = promptInput.value.trim();
  if (prompt === '') {
    return; // Do nothing if prompt is empty
  }

  sendPromptButton.disabled = true; // Disable button during request
  promptInput.disabled = true; // Disable input during request
  promptInput.value = 'Sending...'; // Provide feedback

  try {
    // Send prompt via WebSocket
    ws.send(JSON.stringify({ type: 'ollama_prompt', prompt: prompt }));
    console.log('Prompt sent via WebSocket:', prompt);

    // Clear previous results or indicate new session
    logDiv.innerHTML = ''; // Clear logs for new prompt
    if (finalCodeDisplay) {
      finalCodeDisplay.textContent = ''; // Clear previous code
      finalCodeDisplay.style.display = 'none';
    }

  } catch (error) {
    console.error('Error sending prompt via WebSocket:', error);
    // Display error to user if needed
    logDiv.prepend(createLogEntry('System', `Error: ${error.message}`, 'error'));
  } finally {
    // Keep input disabled until orchestration is done (received ollama_done or error)
    // promptInput.value = ''; // Will clear later after done
    // sendPromptButton.disabled = false;
    // promptInput.disabled = false;
  }
}

// Add a new display area for the final code
const finalCodeDisplay = document.createElement('pre');
finalCodeDisplay.id = 'final-code-display';
finalCodeDisplay.style.cssText = `
  position: absolute;
  bottom: 80px; /* Adjust based on prompt-container height */
  left: 50%;
  transform: translateX(-50%);
  width: 90%;
  max-width: 800px;
  max-height: 400px;
  overflow: auto;
  background: rgba(0, 0, 0, 0.7);
  border: 1px solid #00ffcc;
  border-radius: 8px;
  padding: 15px;
  color: #00ffcc;
  font-family: 'Fira Code', 'Cascadia Code', monospace;
  font-size: 14px;
  z-index: 9;
  display: none; /* Hidden by default */
  white-space: pre-wrap;
  word-break: break-all;
  box-shadow: 0 0 20px rgba(0, 255, 204, 0.3);
`;
document.body.appendChild(finalCodeDisplay);


// websocket
const ws = new WebSocket((location.protocol==='https:'?'wss://':'ws://') + location.host + '/ws');
const logDiv = document.getElementById('log');
ws.onopen = ()=>{ console.log('WS connected'); }; // Changed from log to console.log to avoid confusion with new createLogEntry
ws.onmessage = (ev)=>{
  const now = Date.now();
  try{
    const m = JSON.parse(ev.data);
    const type = m.type;

    if (type === 'ollama_token') {
      const token = m.token;
      // Append token to logDiv or specific output area
      // For now, let's append to logDiv for simplicity, or create a dedicated stream area
      // We can improve this later to stream into a dedicated response area if needed
      logDiv.prepend(createLogEntry('Ollama', token, 'ollama-stream'));
    } else if (type === 'ollama_final_code') {
      const code = m.code;
      finalCodeDisplay.textContent = code;
      finalCodeDisplay.style.display = 'block';
      logDiv.prepend(createLogEntry('System', 'Final code generated!', 'success'));
      sendPromptButton.disabled = false; // Re-enable button
      promptInput.disabled = false; // Re-enable input
      promptInput.value = ''; // Clear input field
    } else if (type === 'ollama_done') {
      logDiv.prepend(createLogEntry('System', 'Orchestration complete.', 'info'));
      sendPromptButton.disabled = false; // Re-enable button
      promptInput.disabled = false; // Re-enable input
      promptInput.value = ''; // Clear input field
    } else if (type === 'error') {
      logDiv.prepend(createLogEntry('Error', m.message, 'error'));
      sendPromptButton.disabled = false; // Re-enable button
      promptInput.disabled = false; // Re-enable input
      promptInput.value = ''; // Clear input field
    } else if (type === 'info') {
      logDiv.prepend(createLogEntry('System', m.message, 'info'));
    }

    // Existing agent activity update logic, if 'agent' and 'text' are still expected
    if (m.agent && m.text) {
      const a = m.agent;
      const txt = m.text;
      nodes[a].last = now;
      
      // Animate connection line
      if (nodes[a].line) {
        nodes[a].line.material.opacity = 1.0; // Make line fully visible
        nodes[a].line.material.color.set(0xff00ff); // Set to a "hot" color
      }

      // Animate token pool
      tokenPool.lastTokenReceived = now; // Mark time of last token

      // update label texture with latest text (short)
      const ctx = nodes[a].tex.image.getContext('2d');
      ctx.clearRect(0,0,256,64);
      ctx.fillStyle='white'; ctx.font='20px monospace';
      ctx.fillText(a + ': ' + (txt.slice(0,40)), 8,34);
      nodes[a].tex.needsUpdate = true;
      // log(a, txt); // Removed duplicate logging if already handled by ollama_token/info

      // Trigger particle burst for this agent
      const n = nodes[a];
      let burstCount = 0;
      for (let p = 0; p < PARTICLE_COUNT_PER_AGENT; p++) {
        if (burstCount >= BURST_PARTICLE_COUNT) break; // Burst a limited number of particles
        if (n.particleStartTimes[p] < 0) { // If particle is inactive
          n.particleStartTimes[p] = now; // Activate particle
          // Reset position to agent's mesh position
          n.particlePositions[p * 3 + 0] = n.mesh.position.x + (Math.random() - 0.5) * 0.1;
          n.particlePositions[p * 3 + 1] = n.mesh.position.y + (Math.random() - 0.5) * 0.1;
          n.particlePositions[p * 3 + 2] = (Math.random() - 0.5) * 0.1;
          
          // Give it a new random outward velocity
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * PARTICLE_SPEED * 2;
          n.particleVelocities[p * 3 + 0] = Math.cos(angle) * speed;
          n.particleVelocities[p * 3 + 1] = Math.sin(angle) * speed;
          n.particleVelocities[p * 3 + 2] = (Math.random() - 0.5) * PARTICLE_SPEED;
          burstCount++;
        }
      }
      n.particlesGeometry.attributes.position.needsUpdate = true;
      n.particlesGeometry.attributes.startTime.needsUpdate = true;
      // End particle burst logic

      // Trigger particle burst for token pool
      let tpBurstCount = 0;
      for (let p = 0; p < TOKEN_POOL_PARTICLE_COUNT; p++) {
        if (tpBurstCount >= BURST_PARTICLE_COUNT * 2) break; // Burst more particles for token pool
        if (tpParticleStartTimes[p] < 0) {
          tpParticleStartTimes[p] = now;
          // Reset position to token pool center
          tpParticlePositions[p * 3 + 0] = tokenPool.position.x + (Math.random() - 0.5) * tokenPool.geometry.parameters.radius * 0.5;
          tpParticlePositions[p * 3 + 1] = tokenPool.position.y + (Math.random() - 0.5) * tokenPool.geometry.parameters.radius * 0.5;
          tpParticlePositions[p * 3 + 2] = tokenPool.position.z + (Math.random() - 0.5) * tokenPool.geometry.parameters.radius * 0.5;

          // Give it a new random outward velocity
          const angleX = Math.random() * Math.PI * 2;
          const angleY = Math.random() * Math.PI * 2;
          const speed = Math.random() * PARTICLE_SPEED * 2;
          tpParticleVelocities[p * 3 + 0] = Math.cos(angleX) * speed;
          tpParticleVelocities[p * 3 + 1] = Math.sin(angleY) * speed;
          tpParticleVelocities[p * 3 + 2] = (Math.random() - 0.5) * PARTICLE_SPEED * 2;
          tpBurstCount++;
        }
      }
      tpParticlesGeometry.attributes.position.needsUpdate = true;
      tpParticlesGeometry.attributes.startTime.needsUpdate = true;
      // End token pool particle burst logic
      
      // Update mock AI status/tokenize data
      nodes[a].status = 'Active';
      nodes[a].tokensUsed += Math.floor(txt.length / 5); // Mock token usage
      nodes[a].lastActivity = new Date().toLocaleTimeString();

      // Set status back to Idle after a short delay
      setTimeout(() => {
        if (nodes[a].status === 'Active') { // Only change if still active
          nodes[a].status = 'Idle';
        }
      }, 3000); // Back to idle after 3 seconds
    }
  }catch(e){ console.warn(e); }
};

// Original log function for agent pulse - keeping it for backward compatibility if other parts of the visualizer use it directly for agent pulses
// For general logging, use createLogEntry wrapped with logDiv.prepend
function log(agentName, messageText){ 
  const p = document.createElement('div');
  const agentSpan = document.createElement('span');
  agentSpan.textContent = `[${agentName}]`;
  agentSpan.classList.add('log-entry-agent-pulse');
  
  // Remove pulse class after a short delay
  setTimeout(() => {
    agentSpan.classList.remove('log-entry-agent-pulse');
  }, 1000); // Pulse for 1 second

  const messageSpan = document.createElement('span');
  messageSpan.textContent = ' ' + messageText; // Add space
  
  p.appendChild(agentSpan);
  p.appendChild(messageSpan);
  
  logDiv.prepend(p);
  while(logDiv.childElementCount>40) logDiv.removeChild(logDiv.lastChild);
}
</script>
</body>
</html>

