<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ollama Kernel: CPU-Bound Matrix v9.0</title>
    <!-- Load required libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        html, body {
            margin: 0;
            overflow: hidden;
            height: 100%;
            background-color: #0d0014; /* Deep Violet/Black */
        }
        #container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        .info-overlay {
            position: absolute;
            top: 0;
            right: 0; 
            padding: 1.5rem;
            color: #d1d5db; 
            font-family: 'Share Tech Mono', monospace;
            text-shadow: 0 0 5px #ff00ff; /* Magenta glow */
            pointer-events: none; 
            z-index: 10;
            max-width: 350px;
            background: rgba(13, 0, 20, 0.8);
            border-bottom-left-radius: 15px;
            border-bottom: 2px solid #ff00ff; /* Magenta border */
            border-left: 1px solid #ff00ff;
        }
        .status-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        .token-log {
            height: 100px;
            overflow-y: scroll;
            margin-top: 10px;
            padding: 5px;
            border: 1px solid #d8b4fe;
            font-size: 0.75rem;
            line-height: 1.2;
            background: rgba(40, 0, 40, 0.6);
            border-radius: 5px;
            pointer-events: all;
        }
        .token {
            color: #f0f0f0; 
        }
        .core-status {
            font-size: 0.8rem;
            margin-top: 5px;
            max-height: 200px;
            overflow-y: scroll;
            color: #fcd34d;
        }
        #gsap-button {
            pointer-events: all;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
            transition: all 0.2s;
            cursor: pointer;
        }
        #gsap-button:hover {
            box-shadow: 0 0 25px rgba(0, 255, 255, 1.0);
            transform: scale(1.05);
        }
        .concept-name {
            font-weight: bold;
        }
        .throttling-indicator {
            color: #f87171;
            text-shadow: 0 0 5px #dc2626;
        }
    </style>
</head>
<body>
    <div id="container">
        <!-- Overlay for Title and Instructions (GSAP/jQuery Managed) -->
        <div class="info-overlay">
            <h1 id="main-title" class="text-2xl font-bold mb-2 text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-fuchsia-500">
                OLLAMA KERNEL V9.0
            </h1>
            <p class="text-sm text-gray-400">CPU-Bound AI Matrix. Monitoring Load.</p>
            
            <!-- Button Section (GSAP Animated) -->
            <div class="mt-4 flex items-center justify-center">
                <button id="gsap-button" 
                    class="p-3 bg-cyan-600 text-white rounded-full font-bold transition duration-300 transform hover:bg-cyan-500">
                    ðŸ§Š Inject Compute (GSAP)
                </button>
            </div>

            <!-- MATRIX STATUS -->
            <hr class="border-gray-700 my-3">
            <div class="mt-4 text-sm font-bold text-teal-400">Kernel Performance</div>
            <div class="status-container text-xs mt-1">
                <p>
                    Current CPU Load: 
                    <strong id="cpu-load" class="text-yellow-300">0%</strong> 
                    <span id="throttle-status" class="text-green-400 ml-2">NORMAL</span>
                </p>
                <div id="load-bar" class="w-full bg-gray-700 h-2 mt-1 rounded-full overflow-hidden">
                    <div id="load-fill" class="h-2 bg-green-500 transition-all duration-300"></div>
                </div>
            </div>
            
            <div class="mt-4 text-sm">
                <p>Input Stream Status: 
                    <span id="connection-dot" class="status-dot bg-yellow-400"></span> 
                    <strong id="connection-status">Initializing...</strong>
                </p>
                <p>TTS Output: 
                    <strong id="tts-status" class="text-yellow-300">Ready</strong>
                </p>
                <div class="core-status" id="neuron-status-container">
                    <!-- High activation nodes inserted here -->
                </div>
                <p class="mt-3 text-sm font-bold text-fuchsia-400">Computational Stream:</p>
                <div class="token-log" id="token-log">
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Core Setup Variables ---
        let scene, camera, renderer;
        let physicsGroup; 
        let neurons = []; 
        let nextNeuronId = 0;
        let synapses = new THREE.Group(); 
        let activations = []; // For visualizing node firing
        let lastTime = 0;
        let rotationY = 0;
        let manualRotation = 0;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        
        // --- Configuration ---
        const FIELD_SIZE = 40;
        const NEURON_COUNT = 30;
        const BASE_ACTIVATION_THRESHOLD = 50;
        const MAX_CPU_LOAD = 100;
        const THRESHOLD_CPU_LOAD = 75; // Start throttling
        
        let CPU_LOAD = 0;
        let THROTTLE_MODE = false;
        let FRAME_SKIP = 1; // 1 = every frame rendered. 2 = every other frame.

        // Visual Mapping
        const CONCEPT_COLORS = [
            { name: 'Inference', color: new THREE.Color(0xff00ff) },
            { name: 'Data_Ingest', color: new THREE.Color(0x00ffff) },
            { name: 'Attention', color: new THREE.Color(0xffff00) },
            { name: 'Weights', color: new THREE.Color(0x00ff00) }
        ];

        // UI elements (jQuery cache)
        const $connectionStatusEl = $('#connection-status');
        const $connectionDotEl = $('#connection-dot');
        const $tokenLogEl = $('#token-log');
        const $neuronStatusContainer = $('#neuron-status-container');
        const $micButtonEl = $('#gsap-button');
        const $ttsStatusEl = $('#tts-status');
        const $cpuLoadEl = $('#cpu-load');
        const $loadFillEl = $('#load-fill');
        const $throttleStatusEl = $('#throttle-status');

        // --- Utility Functions for TTS (PCM to WAV Conversion) ---
        // (Identical to previous versions, only included for completeness)
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function pcmToWav(pcm16, sampleRate) {
            const numChannels = 1;
            const bytesPerSample = 2;
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataSize = pcm16.byteLength;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);
            view.setUint32(0, 0x52494646, true); view.setUint32(4, 36 + dataSize, true);
            view.setUint32(8, 0x57415645, true); view.setUint32(12, 0x666d7420, true);
            view.setUint32(16, 16, true); view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true); view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true); view.setUint16(32, blockAlign, true);
            view.setUint16(34, 16, true); view.setUint32(36, 0x64617461, true);
            view.setUint32(40, dataSize, true);
            const offset = 44;
            for (let i = 0; i < pcm16.length; i++) {
                view.setInt16(offset + i * 2, pcm16[i], true);
            }
            return new Blob([view], { type: 'audio/wav' });
        }

        class SpeechSynthesizer {
            constructor() {
                this.audio = new Audio();
                this.isSpeaking = false;
            }

            async speak(text) {
                if (this.isSpeaking) return;
                $ttsStatusEl.text('Speaking...').removeClass('text-yellow-300').addClass('text-green-400');
                this.isSpeaking = true;
                
                const payload = {
                    contents: [{ parts: [{ text: text }] }],
                    generationConfig: {
                        responseModalities: ["AUDIO"],
                        speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: "Achird" } } }
                    },
                    model: "gemini-2.5-flash-preview-tts"
                };

                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;

                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    if (!response.ok) throw new Error('TTS API failed');
                    const result = await response.json();
                    const part = result?.candidates?.[0]?.content?.parts?.[0];
                    const audioData = part?.inlineData?.data;
                    const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType && mimeType.startsWith("audio/")) {
                        const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                        const sampleRate = sampleRateMatch ? parseInt(sampleRateMatch[1], 10) : 16000;
                        const pcmData = base64ToArrayBuffer(audioData);
                        const pcm16 = new Int16Array(pcmData);
                        const wavBlob = pcmToWav(pcm16, sampleRate);
                        
                        if (this.audio.src) URL.revokeObjectURL(this.audio.src);
                        this.audio.src = URL.createObjectURL(wavBlob);
                        this.audio.play();

                        this.audio.onended = () => {
                            this.isSpeaking = false;
                            $ttsStatusEl.text('Ready').removeClass('text-green-400').addClass('text-yellow-300');
                        };
                    } else {
                        throw new Error("Invalid audio data structure in TTS response.");
                    }
                } catch (error) {
                    console.error("TTS Error:", error);
                    $ttsStatusEl.text('TTS Failed').removeClass('text-green-400').addClass('text-red-400');
                    this.isSpeaking = false;
                    setTimeout(() => $ttsStatusEl.text('Ready').removeClass('text-red-400').addClass('text-yellow-300'), 2000);
                }
            }
        }

        // --- Neuron Definition (The Computational Node) ---
        class Neuron {
            constructor() {
                this.id = nextNeuronId++;
                const conceptData = CONCEPT_COLORS[Math.floor(Math.random() * CONCEPT_COLORS.length)];
                
                this.concept = conceptData.name;
                this.baseColor = conceptData.color.clone();
                this.activation = 0; // 0 to 100
                this.threshold = BASE_ACTIVATION_THRESHOLD;
                
                // Low-Poly Geometry for CPU efficiency
                const baseRadius = 1.0;
                const geometry = new THREE.IcosahedronGeometry(baseRadius, 1); 
                const material = new THREE.MeshPhongMaterial({ 
                    color: this.baseColor, 
                    emissive: 0x000000,
                    specular: 0xaaaaaa,
                    shininess: 50,
                    transparent: true, 
                    opacity: 0.2
                });
                this.mesh = new THREE.Mesh(geometry, material);
                
                this.mesh.position.set(
                    (Math.random() - 0.5) * FIELD_SIZE * 0.8,
                    (Math.random() - 0.5) * FIELD_SIZE * 0.8,
                    (Math.random() - 0.5) * FIELD_SIZE * 0.8
                );
                
                physicsGroup.add(this.mesh);
            }

            applyInput(value) {
                this.activation = Math.min(100, this.activation + value);
            }
            
            updateVisuals() {
                const activationRatio = this.activation / 100;
                
                // Opacity and Emissive based on Activation
                this.mesh.material.opacity = 0.1 + activationRatio * 0.6;
                this.mesh.material.emissive.set(this.baseColor).multiplyScalar(activationRatio * 0.5);
                
                // Scale based on Activation (simple pulse effect)
                const scale = 1.0 + Math.sin(Date.now() * 0.01) * 0.05 + activationRatio * 0.2;
                this.mesh.scale.set(scale, scale, scale);

                // Quick decay
                this.activation = Math.max(0, this.activation - 0.5);
            }

            fire() {
                // Firing event
                this.activation = 5; // Refractory period
                CPU_LOAD = Math.min(MAX_CPU_LOAD, CPU_LOAD + 2); // Firing increases system load
                
                // Create a brief visual burst
                const burst = new THREE.PointLight(this.baseColor, 10, 5, 2);
                burst.position.copy(this.mesh.position);
                physicsGroup.add(burst);
                
                gsap.to(burst, {
                    intensity: 0, 
                    distance: 20,
                    duration: 0.5, 
                    onComplete: () => physicsGroup.remove(burst)
                });
            }
        }


        // --- Ollama Orchestrator (Simulated AI Manager) ---
        class TokenOrchestrator {
            constructor(synthesizer) {
                this.synthesizer = synthesizer;
                this.status = 'Disconnected';
                this.tokenInterval = null;
                this.connect();
            }

            generateToken() {
                const targetNeuron = neurons[Math.floor(Math.random() * neurons.length)];
                if (!targetNeuron) return null;

                const inputType = ['inference_request', 'data_ingestion'][Math.floor(Math.random() * 2)];
                const value = inputType === 'inference_request' ? 35 : 20; // Inference is high load
                
                return {
                    target: targetNeuron.id,
                    targetConcept: targetNeuron.concept,
                    value: value,
                    verbose: `[${inputType.toUpperCase()}] Hitting ${targetNeuron.concept} core (Load: ${value})`
                };
            }

            connect() {
                this.setStatus('Connecting to LLM Input Stream');
                $connectionDotEl.removeClass('bg-red-500').addClass('bg-yellow-400');
                
                setTimeout(() => {
                    this.status = 'Connected';
                    this.setStatus('Connected (Real-time Load)');
                    $connectionDotEl.removeClass('bg-yellow-400').addClass('bg-green-500');
                    this.startTokenStream();
                }, 1000); 
            }

            startTokenStream() {
                if (this.tokenInterval) clearInterval(this.tokenInterval);

                // Use a dynamic interval based on CPU load for better simulation
                this.tokenInterval = setInterval(() => {
                    if (this.status === 'Connected' && neurons.length > 0) {
                        const token = this.generateToken();
                        if (token) {
                            neurons.find(n => n.id === token.target)?.applyInput(token.value);
                            this.logToken(token);
                            CPU_LOAD = Math.min(MAX_CPU_LOAD, CPU_LOAD + (token.value / 15)); // Add load
                        }
                    }
                }, 1000 / (1 + CPU_LOAD / 50)); // Tokens slow down as load increases
            }
            
            processVoiceCommand(command) {
                this.logToken({
                    target: 'USER_INPUT',
                    command: command.toUpperCase(),
                    verbose: `Critical command received: ${command}. Maxing out computational resources.`
                });
                
                if (command === 'inject_compute') {
                    CPU_LOAD = Math.min(MAX_CPU_LOAD, CPU_LOAD + 30);
                    
                    // Force a massive activation spike on random nodes
                    for(let i=0; i<5; i++) {
                        const node = neurons[Math.floor(Math.random() * neurons.length)];
                        if (node) node.applyInput(100);
                    }
                    this.synthesizer.speak(`Warning. Overclocking request initiated. Maximum load spike expected.`);
                }
            }

            logToken(token) {
                const logEntry = $(`<div class="token"></div>`).html(`[ID:${token.target}] ${token.verbose}`);
                
                $tokenLogEl.prepend(logEntry);
                $tokenLogEl.children().slice(10).remove();
            }

            setStatus(message) {
                $connectionStatusEl.text(message);
                this.status = message;
            }
        }
        
        let orchestrator;
        let synthesizer; 

        // --- Initialization and Setup ---

        function init() {
            synthesizer = new SpeechSynthesizer();

            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0d0014, 1, FIELD_SIZE * 1.5);

            // 2. Camera Setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = FIELD_SIZE * 1.5;
            
            // 3. Renderer Setup (No GPU acceleration = software rendering. Keep it minimal.)
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            $('#container').append(renderer.domElement);
            
            // 4. Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 5); 
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);
            
            physicsGroup = new THREE.Group();
            scene.add(physicsGroup);
            physicsGroup.add(synapses);

            createNeurons();
            createSynapticField();
            
            orchestrator = new TokenOrchestrator(synthesizer);

            // 5. Event Listeners and GSAP/jQuery Init
            $(window).on('resize', onWindowResize);
            setupInteractionHandlers(renderer.domElement);
            setupGsapHandler();
            
            // Initial GSAP animation for the title
            gsap.fromTo('#main-title', { opacity: 0, y: -20 }, { opacity: 1, y: 0, duration: 1.5, ease: 'power2.out' });
            
            animate();
        }

        function createNeurons() {
            for (let i = 0; i < NEURON_COUNT; i++) {
                neurons.push(new Neuron());
            }
        }

        function createSynapticField() {
            const positions = [];
            const colors = [];
            const color = new THREE.Color(0x330055); // Dark purple
            
            // Connect nearby nodes to form a sparse mesh
            for(let i=0; i<NEURON_COUNT; i++) {
                for(let j=i+1; j<NEURON_COUNT; j++) {
                    const nA = neurons[i].mesh.position;
                    const nB = neurons[j].mesh.position;
                    if (nA.distanceTo(nB) < 15) {
                        positions.push(nA.x, nA.y, nA.z);
                        positions.push(nB.x, nB.y, nB.z);
                        colors.push(color.r, color.g, color.b);
                        colors.push(color.r, color.g, color.b);
                    }
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const material = new THREE.LineBasicMaterial({
                vertexColors: true, 
                transparent: true, 
                opacity: 0.1, 
                blending: THREE.AdditiveBlending 
            });

            const lines = new THREE.LineSegments(geometry, material);
            synapses.add(lines);
        }

        // --- Core Logic ---

        function updateSimulationState(deltaTime) {
            // 1. CPU Load Decay (CPU cools down naturally)
            CPU_LOAD = Math.max(0, CPU_LOAD - 0.5 * deltaTime * 100);

            // 2. Check for Thermal Throttling
            if (CPU_LOAD > THRESHOLD_CPU_LOAD) {
                if (!THROTTLE_MODE) {
                    THROTTLE_MODE = true;
                    FRAME_SKIP = 2; // Render only every second frame
                    orchestrator.synthesizer.speak("Thermal warning! Initiating CPU throttling.");
                }
                $throttleStatusEl.text('THROTTLE').removeClass('text-green-400').addClass('throttling-indicator');
                $loadFillEl.removeClass('bg-yellow-500 bg-green-500').addClass('bg-red-500');
            } else if (CPU_LOAD > THRESHOLD_CPU_LOAD - 10) {
                // High Load Warning
                $throttleStatusEl.text('HIGH LOAD').removeClass('text-green-400 throttling-indicator').addClass('text-yellow-500');
                $loadFillEl.removeClass('bg-green-500 bg-red-500').addClass('bg-yellow-500');
                THROTTLE_MODE = false;
                FRAME_SKIP = 1;
            } else {
                // Normal
                $throttleStatusEl.text('NORMAL').removeClass('text-yellow-500 throttling-indicator').addClass('text-green-400');
                $loadFillEl.removeClass('bg-yellow-500 bg-red-500').addClass('bg-green-500');
                THROTTLE_MODE = false;
                FRAME_SKIP = 1;
            }
            
            // 3. Update Neurons
            let highActivationHTML = '';
            neurons.forEach(neuron => {
                neuron.updateVisuals();
                if (neuron.activation >= neuron.threshold) {
                    neuron.fire();
                }
                if (neuron.activation > 30) {
                     const color = `#${neuron.mesh.material.color.getHexString()}`;
                     highActivationHTML += `<p style="color:${color};">[${neuron.concept}] Firing: ${Math.round(neuron.activation)}%</p>`;
                }
            });
            $neuronStatusContainer.html(highActivationHTML);
            
            // 4. Update UI Load Bar (GSAP/jQuery for smooth UI)
            $cpuLoadEl.text(`${Math.round(CPU_LOAD)}%`);
            $loadFillEl.css('width', `${CPU_LOAD}%`);
        }
        
        // --- GSAP/jQuery UI Handler ---
        function setupGsapHandler() {
            $micButtonEl.on('click', function() {
                if ($(this).prop('disabled')) return;
                
                $(this).prop('disabled', true);
                
                // GSAP animation for button press
                gsap.to(this, {
                    scale: 1.1, 
                    duration: 0.1, 
                    yoyo: true, 
                    repeat: 1, 
                    ease: "power1.inOut",
                    onComplete: () => {
                        $(this).text('INJECTING...').removeClass('bg-cyan-600 hover:bg-cyan-500').addClass('bg-red-600');
                        orchestrator.processVoiceCommand('inject_compute');
                        
                        // GSAP to return button to normal
                        gsap.delayedCall(3, () => {
                            $(this).prop('disabled', false);
                            $(this).text('ðŸ§Š Inject Compute (GSAP)').removeClass('bg-red-600').addClass('bg-cyan-600 hover:bg-cyan-500');
                        });
                    }
                });
            });
        }


        // --- Animation Loop ---
        let frameCount = 0;
        
        function animate(time) {
            requestAnimationFrame(animate);

            frameCount++;
            const deltaTime = (time - lastTime) / 1000;
            lastTime = time;
            
            updateSimulationState(deltaTime);

            // --- CPU Throttling Logic ---
            // Only render the 3D scene every FRAME_SKIP-th frame.
            if (frameCount % FRAME_SKIP === 0) {
                
                // 1. Rotation Update
                rotationY += (0.001 + (manualRotation * 0.001));
                physicsGroup.rotation.y = rotationY;
                manualRotation *= 0.99; 
                
                // 2. Render
                renderer.render(scene, camera);
            }
        }
        
        // --- Interaction Handlers (Rotation) ---

        function setupInteractionHandlers(element) {
            $(element).on('mousedown touchstart', onPointerDown);
            $(window).on('mouseup touchend', onPointerUp);
            $(window).on('mousemove touchmove', onPointerMove);
        }

        function getClientPosition(event) {
            if (event.originalEvent.touches && event.originalEvent.touches.length > 0) {
                return { x: event.originalEvent.touches[0].clientX, y: event.originalEvent.touches[0].clientY };
            }
            return { x: event.clientX, y: event.clientY };
        }

        function onPointerDown(event) {
            isDragging = true;
            previousMousePosition = getClientPosition(event);
            event.preventDefault();
        }

        function onPointerUp() {
            isDragging = false;
        }

        function onPointerMove(event) {
            if (!isDragging) return;

            const currentPosition = getClientPosition(event);
            const deltaX = currentPosition.x - previousMousePosition.x;
            const deltaY = currentPosition.y - previousMousePosition.y;
            
            manualRotation = deltaX * 0.1;

            physicsGroup.rotation.y += deltaX * 0.005;
            physicsGroup.rotation.x += deltaY * 0.005;

            previousMousePosition = currentPosition;
            event.preventDefault();
        }

        // --- Utility Functions ---

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start everything using jQuery ready function for robustness
        $(document).ready(init);
    </script>
</body>
</html>


