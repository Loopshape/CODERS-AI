<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Quantum Fractal AI Cockpit</title>

<!-- CDN Libraries -->
<script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.23.1/ace.js"></script>

<style>
body{margin:0;font-family:monospace;background:#111;color:#0f0;}
#aiOverlay{position:fixed;top:5px;left:5px;width:95vw;height:95vh;background:#111;color:#0f0;z-index:999999;border-radius:10px;box-shadow:0 0 20px #0f0;display:flex;flex-direction:column;}
#aiHeader{flex:none;padding:5px;background:#222;display:flex;justify-content:space-between;cursor:move;}
#aiHeader button{background:#0f0;color:#000;border:none;padding:2px 6px;}
#aiMain{flex:1;display:flex;overflow:hidden;}
#aiLeft{width:40%;display:flex;flex-direction:column;border-right:1px solid #0f0;}
#aiTabs{flex:none;padding:2px;background:#111;display:flex;gap:2px;}
#aiEditorContainer{flex:1;position:relative;}
#aiEditor{width:100%;height:100%;}
#modelStreams{flex:none;height:100px;overflow:auto;background:#111;border-top:1px solid #0f0;padding:2px;}
#aiRight{flex:1;display:flex;flex-direction:column;}
#aiPreview{flex:1;border:none;}
#ai3D{height:250px;}
#aiConsole{flex:none;padding:5px;background:#111;height:150px;overflow:auto;}
</style>
</head>
<body>

<div id="aiOverlay">
  <div id="aiHeader">
    <span>AI Orchestrator Quantum Dashboard</span>
    <button id="aiClose">X</button>
  </div>
  <div id="aiMain">
    <div id="aiLeft">
      <div id="aiTabs">
        <button id="tabEditor">Editor</button>
        <button id="tabConsole">Console</button>
        <button id="tabReplay">Replay</button>
      </div>
      <div id="aiEditorContainer"><div id="aiEditor"></div></div>
      <div id="modelStreams"></div>
    </div>
    <div id="aiRight">
      <iframe id="aiPreview"></iframe>
      <canvas id="ai3D"></canvas>
    </div>
  </div>
  <div id="aiConsole"></div>
</div>

<script>
(async function(){
'use strict';

const REMOTE_INDEX='https://raw.githubusercontent.com/Loopshape/CODERS-AI/refs/heads/main/index.html';
const LOCAL_MODELS=['cube','core','loop','wave','coin','code'];
let editor, sessionLogs=[], modelObjects={};

// --- Utilities ---
function log(msg){ $('#aiConsole').append('<div>'+msg+'</div>'); $('#aiConsole').scrollTop($('#aiConsole')[0].scrollHeight); }
function logModel(model,msg){
    if(!modelObjects[model]){
        let elem=$('<div><b>'+model+':</b> <span></span></div>').appendTo('#modelStreams');
        modelObjects[model]={span: elem.find('span')[0], particles:[], color:new THREE.Color(Math.random(),Math.random(),Math.random())};
    }
    modelObjects[model].span.textContent=msg;
}

// --- ACE Editor ---
editor=ace.edit("aiEditor");
editor.setTheme("ace/theme/monokai");
editor.session.setMode("ace/mode/html");
editor.setValue("Loading index.html...");

// --- Fetch HTML ---
async function fetchIndex(){
    let html=await new Promise(res=>$.get(REMOTE_INDEX,data=>res(data)));
    if(!/<html/i.test(html)) html=`<html><head></head><body>${html}</body></html>`;
    if(!/<head/i.test(html)) html=html.replace(/<html.*?>/i,'$&<head></head>');
    if(!/<body/i.test(html)) html=html.replace(/<\/head>/i,'$&<body></body>');
    html=html.replace(/<\/head>/i, `
<script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
</head>`);
    editor.setValue(html,-1);
    updatePreview(html);
}
fetchIndex();
function updatePreview(html){ document.getElementById('aiPreview').srcdoc=html; }

// --- Three.js 3D scene ---
const canvas=document.getElementById('ai3D');
const renderer=new THREE.WebGLRenderer({canvas,antialias:true});
const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(50,canvas.clientWidth/canvas.clientHeight,0.1,100);
camera.position.z=10;

// Central final-answer cube
const finalCube=new THREE.Mesh(new THREE.BoxGeometry(2,2,2), new THREE.MeshBasicMaterial({color:0x00ff00}));
scene.add(finalCube);

// Create semantic particle per model
LOCAL_MODELS.forEach((model,i)=>{
    const particles=[];
    for(let j=0;j<12;j++){
        const geo=new THREE.SphereGeometry(0.15,8,8);
        const mat=new THREE.MeshBasicMaterial({color:Math.random()*0xffffff});
        const mesh=new THREE.Mesh(geo,mat);
        mesh.position.set(Math.random()*6-3, Math.random()*4-2, Math.random()*4-2);
        scene.add(mesh);
        particles.push(mesh);
    }
    modelObjects[model].particles=particles;
});

// Animate semantic particles
function animate3D(){
    requestAnimationFrame(animate3D);
    LOCAL_MODELS.forEach(model=>{
        modelObjects[model].particles.forEach(p=>{
            p.position.x += (finalCube.position.x-p.position.x)*0.02;
            p.position.y += (finalCube.position.y-p.position.y)*0.02;
            p.position.z += (finalCube.position.z-p.position.z)*0.02;
        });
    });
    finalCube.rotation.x+=0.005; finalCube.rotation.y+=0.01;
    renderer.setSize(canvas.clientWidth,canvas.clientHeight);
    renderer.render(scene,camera);
}
animate3D();

// GSAP overlay pulse
gsap.to('#aiOverlay',{duration:1.5,scale:1.01,repeat:-1,yoyo:true,ease:'sine.inOut'});

// Ollama simulation for semantic particle updates
async function runOllama(prompt){
    const promises=LOCAL_MODELS.map((model)=>{
        return new Promise(res=>{
            let progress=0;
            const interval=setInterval(()=>{
                progress+=Math.floor(Math.random()*5)+1;
                if(progress>100) progress=100;
                logModel(model,progress+'%');
                modelObjects[model].particles.forEach(p=>{
                    p.material.color.setHSL(Math.random(),1,progress/200+0.25);
                });
                if(progress>=100){ clearInterval(interval); res(`[${model.toUpperCase()}] final chunk`); }
            },Math.random()*100);
        });
    });
    const results=await Promise.all(promises);
    const merged=results.join('\n');
    sessionLogs.push({prompt,merged,time:new Date().toISOString()});
    log('[OLLAMA RESULT]\n'+merged);
    updatePreview(merged);
}

// Hotkeys Shift+Windows
window.addEventListener('keydown',e=>{
    if(e.shiftKey && e.metaKey && e.code==='Space'){ $('#aiOverlay').show(); }
    if(e.shiftKey && e.metaKey && e.code==='KeyE'){ runEnhance(); }
    if(e.shiftKey && e.metaKey && e.code==='KeyR'){ runOllama(editor.getValue()); }
});

// Enhance function
function runEnhance(){
    let val=editor.getValue();
    val = val.replace(/<head(.*?)>/i, `<head$1><style>:root{--main-bg:linear-gradient(135deg,#0f0f2a,#2b1055);}body{background:var(--main-bg);}</style>`);
    val = val.replace(/function\s+([a-zA-Z0-9_]+)\s*\(([^)]*)\)\s*\{/g,'function $1($2){/* AI: optimized */');
    val = val.replace(/\.addEventListener\((['\"])(.*?)\1\s*,/g,'.addEventListener($1$2$1,/* AI: monitored */ ');
    updatePreview(val);
    log('[ENHANCE] Applied');
}

// Close cockpit
$('#aiClose').click(()=>$('#aiOverlay').hide());

})();
</script>

</body>
</html>

